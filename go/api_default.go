/*
sdk_api

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 4.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	itemStockId *string
	createOrUpdateItemStockPhysicalShippingInfoRequest *CreateOrUpdateItemStockPhysicalShippingInfoRequest
}

func (r ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest) MintAccessToken(mintAccessToken string) ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest) ItemStockId(itemStockId string) ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest {
	r.itemStockId = &itemStockId
	return r
}

func (r ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest) CreateOrUpdateItemStockPhysicalShippingInfoRequest(createOrUpdateItemStockPhysicalShippingInfoRequest CreateOrUpdateItemStockPhysicalShippingInfoRequest) ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest {
	r.createOrUpdateItemStockPhysicalShippingInfoRequest = &createOrUpdateItemStockPhysicalShippingInfoRequest
	return r
}

func (r ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest) Execute() (*CreateOrUpdateItemStockPhysicalShippingInfo200Response, *http.Response, error) {
	return r.ApiService.CreateOrUpdateItemStockPhysicalShippingInfoExecute(r)
}

/*
CreateOrUpdateItemStockPhysicalShippingInfo API for creating or updating item stock physical shipping info for given item stock id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest
*/
func (a *DefaultApiService) CreateOrUpdateItemStockPhysicalShippingInfo(ctx context.Context) ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest {
	return ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateOrUpdateItemStockPhysicalShippingInfo200Response
func (a *DefaultApiService) CreateOrUpdateItemStockPhysicalShippingInfoExecute(r ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest) (*CreateOrUpdateItemStockPhysicalShippingInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateOrUpdateItemStockPhysicalShippingInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateOrUpdateItemStockPhysicalShippingInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/itemStockPhysicalShippingInfos/createOrUpdateItemStockPhysicalShippingInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.itemStockId == nil {
		return localVarReturnValue, nil, reportError("itemStockId is required and must be specified")
	}

	localVarQueryParams.Add("itemStockId", parameterToString(*r.itemStockId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	// body params
	localVarPostBody = r.createOrUpdateItemStockPhysicalShippingInfoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateStripePaymentIntentRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	createStripePaymentIntentRequest *CreateStripePaymentIntentRequest
}

func (r ApiCreateStripePaymentIntentRequest) MintAccessToken(mintAccessToken string) ApiCreateStripePaymentIntentRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiCreateStripePaymentIntentRequest) CreateStripePaymentIntentRequest(createStripePaymentIntentRequest CreateStripePaymentIntentRequest) ApiCreateStripePaymentIntentRequest {
	r.createStripePaymentIntentRequest = &createStripePaymentIntentRequest
	return r
}

func (r ApiCreateStripePaymentIntentRequest) Execute() (*CreateStripePaymentIntent200Response, *http.Response, error) {
	return r.ApiService.CreateStripePaymentIntentExecute(r)
}

/*
CreateStripePaymentIntent クレジットカード(Stripe)で指定のアイテムを購入するためのPyamentIntentを作成し、対応するSecretを返す

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateStripePaymentIntentRequest
*/
func (a *DefaultApiService) CreateStripePaymentIntent(ctx context.Context) ApiCreateStripePaymentIntentRequest {
	return ApiCreateStripePaymentIntentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateStripePaymentIntent200Response
func (a *DefaultApiService) CreateStripePaymentIntentExecute(r ApiCreateStripePaymentIntentRequest) (*CreateStripePaymentIntent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateStripePaymentIntent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateStripePaymentIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/stripePayment/createStripePaymentIntent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	// body params
	localVarPostBody = r.createStripePaymentIntentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAvatarRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
}

func (r ApiGetAvatarRequest) MintAccessToken(mintAccessToken string) ApiGetAvatarRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetAvatarRequest) Execute() (*GetAvatar200Response, *http.Response, error) {
	return r.ApiService.GetAvatarExecute(r)
}

/*
GetAvatar アバター画像の署名付きURLの取得

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAvatarRequest
*/
func (a *DefaultApiService) GetAvatar(ctx context.Context) ApiGetAvatarRequest {
	return ApiGetAvatarRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAvatar200Response
func (a *DefaultApiService) GetAvatarExecute(r ApiGetAvatarRequest) (*GetAvatar200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAvatar200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAvatar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/avatar"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBiddedItemStocksByWalletAddressRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	walletAddress *string
	page *string
	perPage *string
	onlyBeforeEnd *string
	sortBy *string
	sortDirection *string
}

func (r ApiGetBiddedItemStocksByWalletAddressRequest) MintAccessToken(mintAccessToken string) ApiGetBiddedItemStocksByWalletAddressRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetBiddedItemStocksByWalletAddressRequest) WalletAddress(walletAddress string) ApiGetBiddedItemStocksByWalletAddressRequest {
	r.walletAddress = &walletAddress
	return r
}

func (r ApiGetBiddedItemStocksByWalletAddressRequest) Page(page string) ApiGetBiddedItemStocksByWalletAddressRequest {
	r.page = &page
	return r
}

func (r ApiGetBiddedItemStocksByWalletAddressRequest) PerPage(perPage string) ApiGetBiddedItemStocksByWalletAddressRequest {
	r.perPage = &perPage
	return r
}

func (r ApiGetBiddedItemStocksByWalletAddressRequest) OnlyBeforeEnd(onlyBeforeEnd string) ApiGetBiddedItemStocksByWalletAddressRequest {
	r.onlyBeforeEnd = &onlyBeforeEnd
	return r
}

func (r ApiGetBiddedItemStocksByWalletAddressRequest) SortBy(sortBy string) ApiGetBiddedItemStocksByWalletAddressRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetBiddedItemStocksByWalletAddressRequest) SortDirection(sortDirection string) ApiGetBiddedItemStocksByWalletAddressRequest {
	r.sortDirection = &sortDirection
	return r
}

func (r ApiGetBiddedItemStocksByWalletAddressRequest) Execute() (*GetBiddedItemStocksByWalletAddress200Response, *http.Response, error) {
	return r.ApiService.GetBiddedItemStocksByWalletAddressExecute(r)
}

/*
GetBiddedItemStocksByWalletAddress 指定したwalletAddressでBidしたItemStockを取得する

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBiddedItemStocksByWalletAddressRequest
*/
func (a *DefaultApiService) GetBiddedItemStocksByWalletAddress(ctx context.Context) ApiGetBiddedItemStocksByWalletAddressRequest {
	return ApiGetBiddedItemStocksByWalletAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBiddedItemStocksByWalletAddress200Response
func (a *DefaultApiService) GetBiddedItemStocksByWalletAddressExecute(r ApiGetBiddedItemStocksByWalletAddressRequest) (*GetBiddedItemStocksByWalletAddress200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBiddedItemStocksByWalletAddress200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetBiddedItemStocksByWalletAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/itemStocks/getBiddedItemStocksByWalletAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.walletAddress == nil {
		return localVarReturnValue, nil, reportError("walletAddress is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.perPage == nil {
		return localVarReturnValue, nil, reportError("perPage is required and must be specified")
	}

	localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	if r.onlyBeforeEnd != nil {
		localVarQueryParams.Add("onlyBeforeEnd", parameterToString(*r.onlyBeforeEnd, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sortDirection", parameterToString(*r.sortDirection, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBoughtItemStocksByWalletAddressRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	walletAddress *string
	page *string
	perPage *string
	sortBy *string
	sortDirection *string
}

func (r ApiGetBoughtItemStocksByWalletAddressRequest) MintAccessToken(mintAccessToken string) ApiGetBoughtItemStocksByWalletAddressRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetBoughtItemStocksByWalletAddressRequest) WalletAddress(walletAddress string) ApiGetBoughtItemStocksByWalletAddressRequest {
	r.walletAddress = &walletAddress
	return r
}

func (r ApiGetBoughtItemStocksByWalletAddressRequest) Page(page string) ApiGetBoughtItemStocksByWalletAddressRequest {
	r.page = &page
	return r
}

func (r ApiGetBoughtItemStocksByWalletAddressRequest) PerPage(perPage string) ApiGetBoughtItemStocksByWalletAddressRequest {
	r.perPage = &perPage
	return r
}

func (r ApiGetBoughtItemStocksByWalletAddressRequest) SortBy(sortBy string) ApiGetBoughtItemStocksByWalletAddressRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetBoughtItemStocksByWalletAddressRequest) SortDirection(sortDirection string) ApiGetBoughtItemStocksByWalletAddressRequest {
	r.sortDirection = &sortDirection
	return r
}

func (r ApiGetBoughtItemStocksByWalletAddressRequest) Execute() (*GetBoughtItemStocksByWalletAddress200Response, *http.Response, error) {
	return r.ApiService.GetBoughtItemStocksByWalletAddressExecute(r)
}

/*
GetBoughtItemStocksByWalletAddress 指定したwalletAddressで購入または落札したItemStockを取得する

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBoughtItemStocksByWalletAddressRequest
*/
func (a *DefaultApiService) GetBoughtItemStocksByWalletAddress(ctx context.Context) ApiGetBoughtItemStocksByWalletAddressRequest {
	return ApiGetBoughtItemStocksByWalletAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBoughtItemStocksByWalletAddress200Response
func (a *DefaultApiService) GetBoughtItemStocksByWalletAddressExecute(r ApiGetBoughtItemStocksByWalletAddressRequest) (*GetBoughtItemStocksByWalletAddress200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBoughtItemStocksByWalletAddress200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetBoughtItemStocksByWalletAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/itemStocks/getBoughtItemStocksByWalletAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.walletAddress == nil {
		return localVarReturnValue, nil, reportError("walletAddress is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.perPage == nil {
		return localVarReturnValue, nil, reportError("perPage is required and must be specified")
	}

	localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sortDirection", parameterToString(*r.sortDirection, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractERC721ByIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	contractId *string
}

func (r ApiGetContractERC721ByIdRequest) MintAccessToken(mintAccessToken string) ApiGetContractERC721ByIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetContractERC721ByIdRequest) ContractId(contractId string) ApiGetContractERC721ByIdRequest {
	r.contractId = &contractId
	return r
}

func (r ApiGetContractERC721ByIdRequest) Execute() (*GetContractERC721ById200Response, *http.Response, error) {
	return r.ApiService.GetContractERC721ByIdExecute(r)
}

/*
GetContractERC721ById ContractERC721をId指定で取得する

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetContractERC721ByIdRequest
*/
func (a *DefaultApiService) GetContractERC721ById(ctx context.Context) ApiGetContractERC721ByIdRequest {
	return ApiGetContractERC721ByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetContractERC721ById200Response
func (a *DefaultApiService) GetContractERC721ByIdExecute(r ApiGetContractERC721ByIdRequest) (*GetContractERC721ById200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetContractERC721ById200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetContractERC721ById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/contracts/getContractERC721ById"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.contractId == nil {
		return localVarReturnValue, nil, reportError("contractId is required and must be specified")
	}

	localVarQueryParams.Add("contractId", parameterToString(*r.contractId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemByIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	itemId string
}

func (r ApiGetItemByIdRequest) MintAccessToken(mintAccessToken string) ApiGetItemByIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetItemByIdRequest) Execute() (*GetItemById200Response, *http.Response, error) {
	return r.ApiService.GetItemByIdExecute(r)
}

/*
GetItemById プロジェクトのItemをId指定で取得する

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId
 @return ApiGetItemByIdRequest
*/
func (a *DefaultApiService) GetItemById(ctx context.Context, itemId string) ApiGetItemByIdRequest {
	return ApiGetItemByIdRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return GetItemById200Response
func (a *DefaultApiService) GetItemByIdExecute(r ApiGetItemByIdRequest) (*GetItemById200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetItemById200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetItemById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/items/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterToString(r.itemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemByTokenERC721Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	tokenId *string
}

func (r ApiGetItemByTokenERC721Request) MintAccessToken(mintAccessToken string) ApiGetItemByTokenERC721Request {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetItemByTokenERC721Request) TokenId(tokenId string) ApiGetItemByTokenERC721Request {
	r.tokenId = &tokenId
	return r
}

func (r ApiGetItemByTokenERC721Request) Execute() (*GetItemById200Response, *http.Response, error) {
	return r.ApiService.GetItemByTokenERC721Execute(r)
}

/*
GetItemByTokenERC721 get item by tokenERC721 id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetItemByTokenERC721Request
*/
func (a *DefaultApiService) GetItemByTokenERC721(ctx context.Context) ApiGetItemByTokenERC721Request {
	return ApiGetItemByTokenERC721Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetItemById200Response
func (a *DefaultApiService) GetItemByTokenERC721Execute(r ApiGetItemByTokenERC721Request) (*GetItemById200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetItemById200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetItemByTokenERC721")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/items/getItemByTokenERC721"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.tokenId == nil {
		return localVarReturnValue, nil, reportError("tokenId is required and must be specified")
	}

	localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemStockByIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	itemStockId *string
}

func (r ApiGetItemStockByIdRequest) MintAccessToken(mintAccessToken string) ApiGetItemStockByIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetItemStockByIdRequest) ItemStockId(itemStockId string) ApiGetItemStockByIdRequest {
	r.itemStockId = &itemStockId
	return r
}

func (r ApiGetItemStockByIdRequest) Execute() (*GetItemStockById200Response, *http.Response, error) {
	return r.ApiService.GetItemStockByIdExecute(r)
}

/*
GetItemStockById ItemStockをId指定で取得する

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetItemStockByIdRequest
*/
func (a *DefaultApiService) GetItemStockById(ctx context.Context) ApiGetItemStockByIdRequest {
	return ApiGetItemStockByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetItemStockById200Response
func (a *DefaultApiService) GetItemStockByIdExecute(r ApiGetItemStockByIdRequest) (*GetItemStockById200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetItemStockById200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetItemStockById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/itemStocks/getById"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.itemStockId == nil {
		return localVarReturnValue, nil, reportError("itemStockId is required and must be specified")
	}

	localVarQueryParams.Add("itemStockId", parameterToString(*r.itemStockId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	itemStockId *string
	getItemStockPhysicalShippingInfoByItemStockIdRequest *GetItemStockPhysicalShippingInfoByItemStockIdRequest
}

func (r ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest) MintAccessToken(mintAccessToken string) ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest) ItemStockId(itemStockId string) ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest {
	r.itemStockId = &itemStockId
	return r
}

func (r ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest) GetItemStockPhysicalShippingInfoByItemStockIdRequest(getItemStockPhysicalShippingInfoByItemStockIdRequest GetItemStockPhysicalShippingInfoByItemStockIdRequest) ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest {
	r.getItemStockPhysicalShippingInfoByItemStockIdRequest = &getItemStockPhysicalShippingInfoByItemStockIdRequest
	return r
}

func (r ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest) Execute() (*GetItemStockPhysicalShippingInfoByItemStockId200Response, *http.Response, error) {
	return r.ApiService.GetItemStockPhysicalShippingInfoByItemStockIdExecute(r)
}

/*
GetItemStockPhysicalShippingInfoByItemStockId API for getting item stock physical shipping info by item stock id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest
*/
func (a *DefaultApiService) GetItemStockPhysicalShippingInfoByItemStockId(ctx context.Context) ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest {
	return ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetItemStockPhysicalShippingInfoByItemStockId200Response
func (a *DefaultApiService) GetItemStockPhysicalShippingInfoByItemStockIdExecute(r ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest) (*GetItemStockPhysicalShippingInfoByItemStockId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetItemStockPhysicalShippingInfoByItemStockId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetItemStockPhysicalShippingInfoByItemStockId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/itemStockPhysicalShippingInfos/getItemStockPhysicalShippingInfoByItemStockId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.itemStockId == nil {
		return localVarReturnValue, nil, reportError("itemStockId is required and must be specified")
	}

	localVarQueryParams.Add("itemStockId", parameterToString(*r.itemStockId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	// body params
	localVarPostBody = r.getItemStockPhysicalShippingInfoByItemStockIdRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	itemStockId *string
}

func (r ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest) MintAccessToken(mintAccessToken string) ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest) ItemStockId(itemStockId string) ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest {
	r.itemStockId = &itemStockId
	return r
}

func (r ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest) Execute() (*GetItemStockPhysicalShippingInfoStatusByItemStockId200Response, *http.Response, error) {
	return r.ApiService.GetItemStockPhysicalShippingInfoStatusByItemStockIdExecute(r)
}

/*
GetItemStockPhysicalShippingInfoStatusByItemStockId API for getting item stock physical shipping info status by item stock id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest
*/
func (a *DefaultApiService) GetItemStockPhysicalShippingInfoStatusByItemStockId(ctx context.Context) ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest {
	return ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetItemStockPhysicalShippingInfoStatusByItemStockId200Response
func (a *DefaultApiService) GetItemStockPhysicalShippingInfoStatusByItemStockIdExecute(r ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest) (*GetItemStockPhysicalShippingInfoStatusByItemStockId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetItemStockPhysicalShippingInfoStatusByItemStockId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetItemStockPhysicalShippingInfoStatusByItemStockId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/itemStockPhysicalShippingInfos/getItemStockPhysicalShippingInfoStatusByItemStockId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.itemStockId == nil {
		return localVarReturnValue, nil, reportError("itemStockId is required and must be specified")
	}

	localVarQueryParams.Add("itemStockId", parameterToString(*r.itemStockId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	page *string
	perPage *string
	saleStatus *string
	onlyAvailableStock *string
	paymentMethod *string
	tags *string
	sortBy *string
	sortDirection *string
}

func (r ApiGetItemsRequest) MintAccessToken(mintAccessToken string) ApiGetItemsRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetItemsRequest) Page(page string) ApiGetItemsRequest {
	r.page = &page
	return r
}

func (r ApiGetItemsRequest) PerPage(perPage string) ApiGetItemsRequest {
	r.perPage = &perPage
	return r
}

func (r ApiGetItemsRequest) SaleStatus(saleStatus string) ApiGetItemsRequest {
	r.saleStatus = &saleStatus
	return r
}

func (r ApiGetItemsRequest) OnlyAvailableStock(onlyAvailableStock string) ApiGetItemsRequest {
	r.onlyAvailableStock = &onlyAvailableStock
	return r
}

func (r ApiGetItemsRequest) PaymentMethod(paymentMethod string) ApiGetItemsRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// , 区切りで指定
func (r ApiGetItemsRequest) Tags(tags string) ApiGetItemsRequest {
	r.tags = &tags
	return r
}

func (r ApiGetItemsRequest) SortBy(sortBy string) ApiGetItemsRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetItemsRequest) SortDirection(sortDirection string) ApiGetItemsRequest {
	r.sortDirection = &sortDirection
	return r
}

func (r ApiGetItemsRequest) Execute() (*GetItems200Response, *http.Response, error) {
	return r.ApiService.GetItemsExecute(r)
}

/*
GetItems プロジェクトのItemを全て取得する

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetItemsRequest
*/
func (a *DefaultApiService) GetItems(ctx context.Context) ApiGetItemsRequest {
	return ApiGetItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetItems200Response
func (a *DefaultApiService) GetItemsExecute(r ApiGetItemsRequest) (*GetItems200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetItems200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.perPage == nil {
		return localVarReturnValue, nil, reportError("perPage is required and must be specified")
	}

	localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	if r.saleStatus != nil {
		localVarQueryParams.Add("saleStatus", parameterToString(*r.saleStatus, ""))
	}
	if r.onlyAvailableStock != nil {
		localVarQueryParams.Add("onlyAvailableStock", parameterToString(*r.onlyAvailableStock, ""))
	}
	if r.paymentMethod != nil {
		localVarQueryParams.Add("paymentMethod", parameterToString(*r.paymentMethod, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sortDirection", parameterToString(*r.sortDirection, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPaymentIntentByIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	paymentIntentId string
}

func (r ApiGetPaymentIntentByIdRequest) MintAccessToken(mintAccessToken string) ApiGetPaymentIntentByIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetPaymentIntentByIdRequest) Execute() (*GetPaymentIntentById200Response, *http.Response, error) {
	return r.ApiService.GetPaymentIntentByIdExecute(r)
}

/*
GetPaymentIntentById This API is responsible to get payment intent by its id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentIntentId
 @return ApiGetPaymentIntentByIdRequest
*/
func (a *DefaultApiService) GetPaymentIntentById(ctx context.Context, paymentIntentId string) ApiGetPaymentIntentByIdRequest {
	return ApiGetPaymentIntentByIdRequest{
		ApiService: a,
		ctx: ctx,
		paymentIntentId: paymentIntentId,
	}
}

// Execute executes the request
//  @return GetPaymentIntentById200Response
func (a *DefaultApiService) GetPaymentIntentByIdExecute(r ApiGetPaymentIntentByIdRequest) (*GetPaymentIntentById200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPaymentIntentById200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPaymentIntentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/paymentIntents/{paymentIntentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentIntentId"+"}", url.PathEscape(parameterToString(r.paymentIntentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProductERC721ByIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	id *string
}

func (r ApiGetProductERC721ByIdRequest) MintAccessToken(mintAccessToken string) ApiGetProductERC721ByIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetProductERC721ByIdRequest) Id(id string) ApiGetProductERC721ByIdRequest {
	r.id = &id
	return r
}

func (r ApiGetProductERC721ByIdRequest) Execute() (*GetProductERC721ById200Response, *http.Response, error) {
	return r.ApiService.GetProductERC721ByIdExecute(r)
}

/*
GetProductERC721ById Itemにパックされていて、ItemのstatusがpublishなProductERC721を取得

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProductERC721ByIdRequest
*/
func (a *DefaultApiService) GetProductERC721ById(ctx context.Context) ApiGetProductERC721ByIdRequest {
	return ApiGetProductERC721ByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetProductERC721ById200Response
func (a *DefaultApiService) GetProductERC721ByIdExecute(r ApiGetProductERC721ByIdRequest) (*GetProductERC721ById200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProductERC721ById200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetProductERC721ById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/products/getProductERC721ById"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	walletAddress *string
}

func (r ApiGetProfileRequest) MintAccessToken(mintAccessToken string) ApiGetProfileRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetProfileRequest) WalletAddress(walletAddress string) ApiGetProfileRequest {
	r.walletAddress = &walletAddress
	return r
}

func (r ApiGetProfileRequest) Execute() (*GetProfile200Response, *http.Response, error) {
	return r.ApiService.GetProfileExecute(r)
}

/*
GetProfile ウォレットに紐づくプロフィールの取得

プロフィールがない場合はnullがdataの値に入る

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProfileRequest
*/
func (a *DefaultApiService) GetProfile(ctx context.Context) ApiGetProfileRequest {
	return ApiGetProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetProfile200Response
func (a *DefaultApiService) GetProfileExecute(r ApiGetProfileRequest) (*GetProfile200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProfile200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/profile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.walletAddress == nil {
		return localVarReturnValue, nil, reportError("walletAddress is required and must be specified")
	}

	localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSellableItemStockERC721IdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	itemId *string
}

func (r ApiGetSellableItemStockERC721IdRequest) MintAccessToken(mintAccessToken string) ApiGetSellableItemStockERC721IdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetSellableItemStockERC721IdRequest) ItemId(itemId string) ApiGetSellableItemStockERC721IdRequest {
	r.itemId = &itemId
	return r
}

func (r ApiGetSellableItemStockERC721IdRequest) Execute() (*GetSellableItemStockERC721Id200Response, *http.Response, error) {
	return r.ApiService.GetSellableItemStockERC721IdExecute(r)
}

/*
GetSellableItemStockERC721Id スマコンで販売している`Item`の販売可能な(まだ売れていない)`ItemStockId`を取得する

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSellableItemStockERC721IdRequest
*/
func (a *DefaultApiService) GetSellableItemStockERC721Id(ctx context.Context) ApiGetSellableItemStockERC721IdRequest {
	return ApiGetSellableItemStockERC721IdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSellableItemStockERC721Id200Response
func (a *DefaultApiService) GetSellableItemStockERC721IdExecute(r ApiGetSellableItemStockERC721IdRequest) (*GetSellableItemStockERC721Id200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSellableItemStockERC721Id200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSellableItemStockERC721Id")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/items/getSellableItemStockERC721Id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.itemId == nil {
		return localVarReturnValue, nil, reportError("itemId is required and must be specified")
	}

	localVarQueryParams.Add("itemId", parameterToString(*r.itemId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSignByItemStockIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	itemStockId *string
	signatureType *SignatureType
	walletAddress *string
	residence *string
}

func (r ApiGetSignByItemStockIdRequest) MintAccessToken(mintAccessToken string) ApiGetSignByItemStockIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetSignByItemStockIdRequest) ItemStockId(itemStockId string) ApiGetSignByItemStockIdRequest {
	r.itemStockId = &itemStockId
	return r
}

func (r ApiGetSignByItemStockIdRequest) SignatureType(signatureType SignatureType) ApiGetSignByItemStockIdRequest {
	r.signatureType = &signatureType
	return r
}

// 購入時のみ必須
func (r ApiGetSignByItemStockIdRequest) WalletAddress(walletAddress string) ApiGetSignByItemStockIdRequest {
	r.walletAddress = &walletAddress
	return r
}

// 購入時のみ必須
func (r ApiGetSignByItemStockIdRequest) Residence(residence string) ApiGetSignByItemStockIdRequest {
	r.residence = &residence
	return r
}

func (r ApiGetSignByItemStockIdRequest) Execute() (*GetSignByItemStockId200Response, *http.Response, error) {
	return r.ApiService.GetSignByItemStockIdExecute(r)
}

/*
GetSignByItemStockId Item購入に関してスマコンの操作に必要なSignを返す

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSignByItemStockIdRequest
*/
func (a *DefaultApiService) GetSignByItemStockId(ctx context.Context) ApiGetSignByItemStockIdRequest {
	return ApiGetSignByItemStockIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSignByItemStockId200Response
func (a *DefaultApiService) GetSignByItemStockIdExecute(r ApiGetSignByItemStockIdRequest) (*GetSignByItemStockId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSignByItemStockId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSignByItemStockId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/itemStocks/sign"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.itemStockId == nil {
		return localVarReturnValue, nil, reportError("itemStockId is required and must be specified")
	}
	if r.signatureType == nil {
		return localVarReturnValue, nil, reportError("signatureType is required and must be specified")
	}

	localVarQueryParams.Add("itemStockId", parameterToString(*r.itemStockId, ""))
	localVarQueryParams.Add("signatureType", parameterToString(*r.signatureType, ""))
	if r.walletAddress != nil {
		localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	}
	if r.residence != nil {
		localVarQueryParams.Add("residence", parameterToString(*r.residence, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokenERC721ByIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	tokenId string
}

func (r ApiGetTokenERC721ByIdRequest) MintAccessToken(mintAccessToken string) ApiGetTokenERC721ByIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetTokenERC721ByIdRequest) Execute() (*GetTokenERC721ById200Response, *http.Response, error) {
	return r.ApiService.GetTokenERC721ByIdExecute(r)
}

/*
GetTokenERC721ById get TokenERC721 by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tokenId
 @return ApiGetTokenERC721ByIdRequest
*/
func (a *DefaultApiService) GetTokenERC721ById(ctx context.Context, tokenId string) ApiGetTokenERC721ByIdRequest {
	return ApiGetTokenERC721ByIdRequest{
		ApiService: a,
		ctx: ctx,
		tokenId: tokenId,
	}
}

// Execute executes the request
//  @return GetTokenERC721ById200Response
func (a *DefaultApiService) GetTokenERC721ByIdExecute(r ApiGetTokenERC721ByIdRequest) (*GetTokenERC721ById200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTokenERC721ById200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTokenERC721ById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/tokens/{tokenId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tokenId"+"}", url.PathEscape(parameterToString(r.tokenId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokenERC721sByWalletAddressRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	walletAddress *string
	page *string
	perPage *string
}

func (r ApiGetTokenERC721sByWalletAddressRequest) MintAccessToken(mintAccessToken string) ApiGetTokenERC721sByWalletAddressRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetTokenERC721sByWalletAddressRequest) WalletAddress(walletAddress string) ApiGetTokenERC721sByWalletAddressRequest {
	r.walletAddress = &walletAddress
	return r
}

func (r ApiGetTokenERC721sByWalletAddressRequest) Page(page string) ApiGetTokenERC721sByWalletAddressRequest {
	r.page = &page
	return r
}

func (r ApiGetTokenERC721sByWalletAddressRequest) PerPage(perPage string) ApiGetTokenERC721sByWalletAddressRequest {
	r.perPage = &perPage
	return r
}

func (r ApiGetTokenERC721sByWalletAddressRequest) Execute() (*GetTokenERC721sByWalletAddress200Response, *http.Response, error) {
	return r.ApiService.GetTokenERC721sByWalletAddressExecute(r)
}

/*
GetTokenERC721sByWalletAddress walletAddressに紐づくTokenERC721を全て取得する

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTokenERC721sByWalletAddressRequest
*/
func (a *DefaultApiService) GetTokenERC721sByWalletAddress(ctx context.Context) ApiGetTokenERC721sByWalletAddressRequest {
	return ApiGetTokenERC721sByWalletAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTokenERC721sByWalletAddress200Response
func (a *DefaultApiService) GetTokenERC721sByWalletAddressExecute(r ApiGetTokenERC721sByWalletAddressRequest) (*GetTokenERC721sByWalletAddress200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTokenERC721sByWalletAddress200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTokenERC721sByWalletAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/tokens/getTokenERC721sByWalletAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.walletAddress == nil {
		return localVarReturnValue, nil, reportError("walletAddress is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.perPage == nil {
		return localVarReturnValue, nil, reportError("perPage is required and must be specified")
	}

	localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokentERC721sByWalletAddressFromAnyContractRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	walletAddress *string
	contractAddress *string
}

func (r ApiGetTokentERC721sByWalletAddressFromAnyContractRequest) MintAccessToken(mintAccessToken string) ApiGetTokentERC721sByWalletAddressFromAnyContractRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetTokentERC721sByWalletAddressFromAnyContractRequest) WalletAddress(walletAddress string) ApiGetTokentERC721sByWalletAddressFromAnyContractRequest {
	r.walletAddress = &walletAddress
	return r
}

func (r ApiGetTokentERC721sByWalletAddressFromAnyContractRequest) ContractAddress(contractAddress string) ApiGetTokentERC721sByWalletAddressFromAnyContractRequest {
	r.contractAddress = &contractAddress
	return r
}

func (r ApiGetTokentERC721sByWalletAddressFromAnyContractRequest) Execute() (*GetTokenERC721sByWalletAddress200Response, *http.Response, error) {
	return r.ApiService.GetTokentERC721sByWalletAddressFromAnyContractExecute(r)
}

/*
GetTokentERC721sByWalletAddressFromAnyContract get TokenERC721s by specifying wallet address and contract address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTokentERC721sByWalletAddressFromAnyContractRequest
*/
func (a *DefaultApiService) GetTokentERC721sByWalletAddressFromAnyContract(ctx context.Context) ApiGetTokentERC721sByWalletAddressFromAnyContractRequest {
	return ApiGetTokentERC721sByWalletAddressFromAnyContractRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTokenERC721sByWalletAddress200Response
func (a *DefaultApiService) GetTokentERC721sByWalletAddressFromAnyContractExecute(r ApiGetTokentERC721sByWalletAddressFromAnyContractRequest) (*GetTokenERC721sByWalletAddress200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTokenERC721sByWalletAddress200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTokentERC721sByWalletAddressFromAnyContract")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/tokens/getTokentERC721sByWalletAddressFromAnyContract"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.walletAddress == nil {
		return localVarReturnValue, nil, reportError("walletAddress is required and must be specified")
	}
	if r.contractAddress == nil {
		return localVarReturnValue, nil, reportError("contractAddress is required and must be specified")
	}

	localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	localVarQueryParams.Add("contractAddress", parameterToString(*r.contractAddress, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHasNftRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	walletAddress *string
	contractAddress *string
	tokenId *string
}

func (r ApiHasNftRequest) MintAccessToken(mintAccessToken string) ApiHasNftRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiHasNftRequest) WalletAddress(walletAddress string) ApiHasNftRequest {
	r.walletAddress = &walletAddress
	return r
}

func (r ApiHasNftRequest) ContractAddress(contractAddress string) ApiHasNftRequest {
	r.contractAddress = &contractAddress
	return r
}

func (r ApiHasNftRequest) TokenId(tokenId string) ApiHasNftRequest {
	r.tokenId = &tokenId
	return r
}

func (r ApiHasNftRequest) Execute() (*HasNfts200Response, *http.Response, error) {
	return r.ApiService.HasNftExecute(r)
}

/*
HasNft has token id of nft or not in contract

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHasNftRequest
*/
func (a *DefaultApiService) HasNft(ctx context.Context) ApiHasNftRequest {
	return ApiHasNftRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HasNfts200Response
func (a *DefaultApiService) HasNftExecute(r ApiHasNftRequest) (*HasNfts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HasNfts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.HasNft")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/tokens/hasNft"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.walletAddress == nil {
		return localVarReturnValue, nil, reportError("walletAddress is required and must be specified")
	}
	if r.contractAddress == nil {
		return localVarReturnValue, nil, reportError("contractAddress is required and must be specified")
	}
	if r.tokenId == nil {
		return localVarReturnValue, nil, reportError("tokenId is required and must be specified")
	}

	localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	localVarQueryParams.Add("contractAddress", parameterToString(*r.contractAddress, ""))
	localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHasNftsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	walletAddress *string
	contractAddress *string
}

func (r ApiHasNftsRequest) MintAccessToken(mintAccessToken string) ApiHasNftsRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiHasNftsRequest) WalletAddress(walletAddress string) ApiHasNftsRequest {
	r.walletAddress = &walletAddress
	return r
}

func (r ApiHasNftsRequest) ContractAddress(contractAddress string) ApiHasNftsRequest {
	r.contractAddress = &contractAddress
	return r
}

func (r ApiHasNftsRequest) Execute() (*HasNfts200Response, *http.Response, error) {
	return r.ApiService.HasNftsExecute(r)
}

/*
HasNfts has nfts or not in contract

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHasNftsRequest
*/
func (a *DefaultApiService) HasNfts(ctx context.Context) ApiHasNftsRequest {
	return ApiHasNftsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HasNfts200Response
func (a *DefaultApiService) HasNftsExecute(r ApiHasNftsRequest) (*HasNfts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HasNfts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.HasNfts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/tokens/hasNfts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.walletAddress == nil {
		return localVarReturnValue, nil, reportError("walletAddress is required and must be specified")
	}
	if r.contractAddress == nil {
		return localVarReturnValue, nil, reportError("contractAddress is required and must be specified")
	}

	localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	localVarQueryParams.Add("contractAddress", parameterToString(*r.contractAddress, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProfileRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	updateProfileRequest *UpdateProfileRequest
}

func (r ApiUpdateProfileRequest) MintAccessToken(mintAccessToken string) ApiUpdateProfileRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiUpdateProfileRequest) UpdateProfileRequest(updateProfileRequest UpdateProfileRequest) ApiUpdateProfileRequest {
	r.updateProfileRequest = &updateProfileRequest
	return r
}

func (r ApiUpdateProfileRequest) Execute() (*UpdateProfile200Response, *http.Response, error) {
	return r.ApiService.UpdateProfileExecute(r)
}

/*
UpdateProfile ウォレットに紐づくプロフィールの作成

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateProfileRequest
*/
func (a *DefaultApiService) UpdateProfile(ctx context.Context) ApiUpdateProfileRequest {
	return ApiUpdateProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateProfile200Response
func (a *DefaultApiService) UpdateProfileExecute(r ApiUpdateProfileRequest) (*UpdateProfile200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateProfile200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/profile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	// body params
	localVarPostBody = r.updateProfileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetItems400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
