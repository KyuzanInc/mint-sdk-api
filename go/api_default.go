/*
 * sdk_api
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 4.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	itemStockId *string
	inlineObject1 *InlineObject1
}

func (r ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest) MintAccessToken(mintAccessToken string) ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest) ItemStockId(itemStockId string) ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest {
	r.itemStockId = &itemStockId
	return r
}
func (r ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest) InlineObject1(inlineObject1 InlineObject1) ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest {
	r.inlineObject1 = &inlineObject1
	return r
}

func (r ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest) Execute() (InlineResponse2009, *_nethttp.Response, error) {
	return r.ApiService.CreateOrUpdateItemStockPhysicalShippingInfoExecute(r)
}

/*
 * CreateOrUpdateItemStockPhysicalShippingInfo API for creating or updating item stock physical shipping info for given item stock id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest
 */
func (a *DefaultApiService) CreateOrUpdateItemStockPhysicalShippingInfo(ctx _context.Context) ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest {
	return ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2009
 */
func (a *DefaultApiService) CreateOrUpdateItemStockPhysicalShippingInfoExecute(r ApiCreateOrUpdateItemStockPhysicalShippingInfoRequest) (InlineResponse2009, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2009
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateOrUpdateItemStockPhysicalShippingInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/itemStockPhysicalShippingInfos/createOrUpdateItemStockPhysicalShippingInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.itemStockId == nil {
		return localVarReturnValue, nil, reportError("itemStockId is required and must be specified")
	}

	localVarQueryParams.Add("itemStockId", parameterToString(*r.itemStockId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	// body params
	localVarPostBody = r.inlineObject1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateStripePaymentIntentRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	inlineObject3 *InlineObject3
}

func (r ApiCreateStripePaymentIntentRequest) MintAccessToken(mintAccessToken string) ApiCreateStripePaymentIntentRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiCreateStripePaymentIntentRequest) InlineObject3(inlineObject3 InlineObject3) ApiCreateStripePaymentIntentRequest {
	r.inlineObject3 = &inlineObject3
	return r
}

func (r ApiCreateStripePaymentIntentRequest) Execute() (InlineResponse20019, *_nethttp.Response, error) {
	return r.ApiService.CreateStripePaymentIntentExecute(r)
}

/*
 * CreateStripePaymentIntent クレジットカード(Stripe)で指定のアイテムを購入するためのPyamentIntentを作成し、対応するSecretを返す
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateStripePaymentIntentRequest
 */
func (a *DefaultApiService) CreateStripePaymentIntent(ctx _context.Context) ApiCreateStripePaymentIntentRequest {
	return ApiCreateStripePaymentIntentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20019
 */
func (a *DefaultApiService) CreateStripePaymentIntentExecute(r ApiCreateStripePaymentIntentRequest) (InlineResponse20019, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20019
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateStripePaymentIntent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/stripePayment/createStripePaymentIntent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	// body params
	localVarPostBody = r.inlineObject3
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAvatarRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
}

func (r ApiGetAvatarRequest) MintAccessToken(mintAccessToken string) ApiGetAvatarRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetAvatarRequest) Execute() (InlineResponse20017, *_nethttp.Response, error) {
	return r.ApiService.GetAvatarExecute(r)
}

/*
 * GetAvatar アバター画像の署名付きURLの取得
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetAvatarRequest
 */
func (a *DefaultApiService) GetAvatar(ctx _context.Context) ApiGetAvatarRequest {
	return ApiGetAvatarRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20017
 */
func (a *DefaultApiService) GetAvatarExecute(r ApiGetAvatarRequest) (InlineResponse20017, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20017
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAvatar")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/avatar"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBiddedItemStocksByWalletAddressRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	walletAddress *string
	page *string
	perPage *string
	onlyBeforeEnd *string
	sortBy *string
	sortDirection *string
}

func (r ApiGetBiddedItemStocksByWalletAddressRequest) MintAccessToken(mintAccessToken string) ApiGetBiddedItemStocksByWalletAddressRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiGetBiddedItemStocksByWalletAddressRequest) WalletAddress(walletAddress string) ApiGetBiddedItemStocksByWalletAddressRequest {
	r.walletAddress = &walletAddress
	return r
}
func (r ApiGetBiddedItemStocksByWalletAddressRequest) Page(page string) ApiGetBiddedItemStocksByWalletAddressRequest {
	r.page = &page
	return r
}
func (r ApiGetBiddedItemStocksByWalletAddressRequest) PerPage(perPage string) ApiGetBiddedItemStocksByWalletAddressRequest {
	r.perPage = &perPage
	return r
}
func (r ApiGetBiddedItemStocksByWalletAddressRequest) OnlyBeforeEnd(onlyBeforeEnd string) ApiGetBiddedItemStocksByWalletAddressRequest {
	r.onlyBeforeEnd = &onlyBeforeEnd
	return r
}
func (r ApiGetBiddedItemStocksByWalletAddressRequest) SortBy(sortBy string) ApiGetBiddedItemStocksByWalletAddressRequest {
	r.sortBy = &sortBy
	return r
}
func (r ApiGetBiddedItemStocksByWalletAddressRequest) SortDirection(sortDirection string) ApiGetBiddedItemStocksByWalletAddressRequest {
	r.sortDirection = &sortDirection
	return r
}

func (r ApiGetBiddedItemStocksByWalletAddressRequest) Execute() (InlineResponse2005, *_nethttp.Response, error) {
	return r.ApiService.GetBiddedItemStocksByWalletAddressExecute(r)
}

/*
 * GetBiddedItemStocksByWalletAddress 指定したwalletAddressでBidしたItemStockを取得する
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetBiddedItemStocksByWalletAddressRequest
 */
func (a *DefaultApiService) GetBiddedItemStocksByWalletAddress(ctx _context.Context) ApiGetBiddedItemStocksByWalletAddressRequest {
	return ApiGetBiddedItemStocksByWalletAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2005
 */
func (a *DefaultApiService) GetBiddedItemStocksByWalletAddressExecute(r ApiGetBiddedItemStocksByWalletAddressRequest) (InlineResponse2005, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2005
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetBiddedItemStocksByWalletAddress")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/itemStocks/getBiddedItemStocksByWalletAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.walletAddress == nil {
		return localVarReturnValue, nil, reportError("walletAddress is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.perPage == nil {
		return localVarReturnValue, nil, reportError("perPage is required and must be specified")
	}

	localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	if r.onlyBeforeEnd != nil {
		localVarQueryParams.Add("onlyBeforeEnd", parameterToString(*r.onlyBeforeEnd, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sortDirection", parameterToString(*r.sortDirection, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBoughtItemStocksByWalletAddressRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	walletAddress *string
	page *string
	perPage *string
	sortBy *string
	sortDirection *string
}

func (r ApiGetBoughtItemStocksByWalletAddressRequest) MintAccessToken(mintAccessToken string) ApiGetBoughtItemStocksByWalletAddressRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiGetBoughtItemStocksByWalletAddressRequest) WalletAddress(walletAddress string) ApiGetBoughtItemStocksByWalletAddressRequest {
	r.walletAddress = &walletAddress
	return r
}
func (r ApiGetBoughtItemStocksByWalletAddressRequest) Page(page string) ApiGetBoughtItemStocksByWalletAddressRequest {
	r.page = &page
	return r
}
func (r ApiGetBoughtItemStocksByWalletAddressRequest) PerPage(perPage string) ApiGetBoughtItemStocksByWalletAddressRequest {
	r.perPage = &perPage
	return r
}
func (r ApiGetBoughtItemStocksByWalletAddressRequest) SortBy(sortBy string) ApiGetBoughtItemStocksByWalletAddressRequest {
	r.sortBy = &sortBy
	return r
}
func (r ApiGetBoughtItemStocksByWalletAddressRequest) SortDirection(sortDirection string) ApiGetBoughtItemStocksByWalletAddressRequest {
	r.sortDirection = &sortDirection
	return r
}

func (r ApiGetBoughtItemStocksByWalletAddressRequest) Execute() (InlineResponse2006, *_nethttp.Response, error) {
	return r.ApiService.GetBoughtItemStocksByWalletAddressExecute(r)
}

/*
 * GetBoughtItemStocksByWalletAddress 指定したwalletAddressで購入または落札したItemStockを取得する
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetBoughtItemStocksByWalletAddressRequest
 */
func (a *DefaultApiService) GetBoughtItemStocksByWalletAddress(ctx _context.Context) ApiGetBoughtItemStocksByWalletAddressRequest {
	return ApiGetBoughtItemStocksByWalletAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2006
 */
func (a *DefaultApiService) GetBoughtItemStocksByWalletAddressExecute(r ApiGetBoughtItemStocksByWalletAddressRequest) (InlineResponse2006, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2006
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetBoughtItemStocksByWalletAddress")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/itemStocks/getBoughtItemStocksByWalletAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.walletAddress == nil {
		return localVarReturnValue, nil, reportError("walletAddress is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.perPage == nil {
		return localVarReturnValue, nil, reportError("perPage is required and must be specified")
	}

	localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sortDirection", parameterToString(*r.sortDirection, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractERC721ByIdRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	contractId *string
}

func (r ApiGetContractERC721ByIdRequest) MintAccessToken(mintAccessToken string) ApiGetContractERC721ByIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiGetContractERC721ByIdRequest) ContractId(contractId string) ApiGetContractERC721ByIdRequest {
	r.contractId = &contractId
	return r
}

func (r ApiGetContractERC721ByIdRequest) Execute() (InlineResponse20018, *_nethttp.Response, error) {
	return r.ApiService.GetContractERC721ByIdExecute(r)
}

/*
 * GetContractERC721ById ContractERC721をId指定で取得する
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetContractERC721ByIdRequest
 */
func (a *DefaultApiService) GetContractERC721ById(ctx _context.Context) ApiGetContractERC721ByIdRequest {
	return ApiGetContractERC721ByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20018
 */
func (a *DefaultApiService) GetContractERC721ByIdExecute(r ApiGetContractERC721ByIdRequest) (InlineResponse20018, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20018
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetContractERC721ById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/contracts/getContractERC721ById"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.contractId == nil {
		return localVarReturnValue, nil, reportError("contractId is required and must be specified")
	}

	localVarQueryParams.Add("contractId", parameterToString(*r.contractId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemByIdRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	itemId string
}

func (r ApiGetItemByIdRequest) MintAccessToken(mintAccessToken string) ApiGetItemByIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetItemByIdRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.GetItemByIdExecute(r)
}

/*
 * GetItemById プロジェクトのItemをId指定で取得する
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId
 * @return ApiGetItemByIdRequest
 */
func (a *DefaultApiService) GetItemById(ctx _context.Context, itemId string) ApiGetItemByIdRequest {
	return ApiGetItemByIdRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *DefaultApiService) GetItemByIdExecute(r ApiGetItemByIdRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetItemById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/items/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.PathEscape(parameterToString(r.itemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemByTokenERC721Request struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	tokenId *string
}

func (r ApiGetItemByTokenERC721Request) MintAccessToken(mintAccessToken string) ApiGetItemByTokenERC721Request {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiGetItemByTokenERC721Request) TokenId(tokenId string) ApiGetItemByTokenERC721Request {
	r.tokenId = &tokenId
	return r
}

func (r ApiGetItemByTokenERC721Request) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.GetItemByTokenERC721Execute(r)
}

/*
 * GetItemByTokenERC721 get item by tokenERC721 id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetItemByTokenERC721Request
 */
func (a *DefaultApiService) GetItemByTokenERC721(ctx _context.Context) ApiGetItemByTokenERC721Request {
	return ApiGetItemByTokenERC721Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *DefaultApiService) GetItemByTokenERC721Execute(r ApiGetItemByTokenERC721Request) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetItemByTokenERC721")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/items/getItemByTokenERC721"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.tokenId == nil {
		return localVarReturnValue, nil, reportError("tokenId is required and must be specified")
	}

	localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemStockByIdRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	itemStockId *string
}

func (r ApiGetItemStockByIdRequest) MintAccessToken(mintAccessToken string) ApiGetItemStockByIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiGetItemStockByIdRequest) ItemStockId(itemStockId string) ApiGetItemStockByIdRequest {
	r.itemStockId = &itemStockId
	return r
}

func (r ApiGetItemStockByIdRequest) Execute() (InlineResponse2004, *_nethttp.Response, error) {
	return r.ApiService.GetItemStockByIdExecute(r)
}

/*
 * GetItemStockById ItemStockをId指定で取得する
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetItemStockByIdRequest
 */
func (a *DefaultApiService) GetItemStockById(ctx _context.Context) ApiGetItemStockByIdRequest {
	return ApiGetItemStockByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2004
 */
func (a *DefaultApiService) GetItemStockByIdExecute(r ApiGetItemStockByIdRequest) (InlineResponse2004, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2004
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetItemStockById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/itemStocks/getById"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.itemStockId == nil {
		return localVarReturnValue, nil, reportError("itemStockId is required and must be specified")
	}

	localVarQueryParams.Add("itemStockId", parameterToString(*r.itemStockId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	itemStockId *string
	inlineObject *InlineObject
}

func (r ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest) MintAccessToken(mintAccessToken string) ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest) ItemStockId(itemStockId string) ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest {
	r.itemStockId = &itemStockId
	return r
}
func (r ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest) InlineObject(inlineObject InlineObject) ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest {
	r.inlineObject = &inlineObject
	return r
}

func (r ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest) Execute() (InlineResponse2008, *_nethttp.Response, error) {
	return r.ApiService.GetItemStockPhysicalShippingInfoByItemStockIdExecute(r)
}

/*
 * GetItemStockPhysicalShippingInfoByItemStockId API for getting item stock physical shipping info by item stock id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest
 */
func (a *DefaultApiService) GetItemStockPhysicalShippingInfoByItemStockId(ctx _context.Context) ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest {
	return ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2008
 */
func (a *DefaultApiService) GetItemStockPhysicalShippingInfoByItemStockIdExecute(r ApiGetItemStockPhysicalShippingInfoByItemStockIdRequest) (InlineResponse2008, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2008
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetItemStockPhysicalShippingInfoByItemStockId")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/itemStockPhysicalShippingInfos/getItemStockPhysicalShippingInfoByItemStockId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.itemStockId == nil {
		return localVarReturnValue, nil, reportError("itemStockId is required and must be specified")
	}

	localVarQueryParams.Add("itemStockId", parameterToString(*r.itemStockId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	// body params
	localVarPostBody = r.inlineObject
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	itemStockId *string
}

func (r ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest) MintAccessToken(mintAccessToken string) ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest) ItemStockId(itemStockId string) ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest {
	r.itemStockId = &itemStockId
	return r
}

func (r ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest) Execute() (InlineResponse2007, *_nethttp.Response, error) {
	return r.ApiService.GetItemStockPhysicalShippingInfoStatusByItemStockIdExecute(r)
}

/*
 * GetItemStockPhysicalShippingInfoStatusByItemStockId API for getting item stock physical shipping info status by item stock id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest
 */
func (a *DefaultApiService) GetItemStockPhysicalShippingInfoStatusByItemStockId(ctx _context.Context) ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest {
	return ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2007
 */
func (a *DefaultApiService) GetItemStockPhysicalShippingInfoStatusByItemStockIdExecute(r ApiGetItemStockPhysicalShippingInfoStatusByItemStockIdRequest) (InlineResponse2007, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2007
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetItemStockPhysicalShippingInfoStatusByItemStockId")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/itemStockPhysicalShippingInfos/getItemStockPhysicalShippingInfoStatusByItemStockId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.itemStockId == nil {
		return localVarReturnValue, nil, reportError("itemStockId is required and must be specified")
	}

	localVarQueryParams.Add("itemStockId", parameterToString(*r.itemStockId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	page *string
	perPage *string
	saleStatus *string
	onlyAvailableStock *string
	paymentMethod *string
	tags *string
	sortBy *string
	sortDirection *string
}

func (r ApiGetItemsRequest) MintAccessToken(mintAccessToken string) ApiGetItemsRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiGetItemsRequest) Page(page string) ApiGetItemsRequest {
	r.page = &page
	return r
}
func (r ApiGetItemsRequest) PerPage(perPage string) ApiGetItemsRequest {
	r.perPage = &perPage
	return r
}
func (r ApiGetItemsRequest) SaleStatus(saleStatus string) ApiGetItemsRequest {
	r.saleStatus = &saleStatus
	return r
}
func (r ApiGetItemsRequest) OnlyAvailableStock(onlyAvailableStock string) ApiGetItemsRequest {
	r.onlyAvailableStock = &onlyAvailableStock
	return r
}
func (r ApiGetItemsRequest) PaymentMethod(paymentMethod string) ApiGetItemsRequest {
	r.paymentMethod = &paymentMethod
	return r
}
func (r ApiGetItemsRequest) Tags(tags string) ApiGetItemsRequest {
	r.tags = &tags
	return r
}
func (r ApiGetItemsRequest) SortBy(sortBy string) ApiGetItemsRequest {
	r.sortBy = &sortBy
	return r
}
func (r ApiGetItemsRequest) SortDirection(sortDirection string) ApiGetItemsRequest {
	r.sortDirection = &sortDirection
	return r
}

func (r ApiGetItemsRequest) Execute() (InlineResponse200, *_nethttp.Response, error) {
	return r.ApiService.GetItemsExecute(r)
}

/*
 * GetItems プロジェクトのItemを全て取得する
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetItemsRequest
 */
func (a *DefaultApiService) GetItems(ctx _context.Context) ApiGetItemsRequest {
	return ApiGetItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200
 */
func (a *DefaultApiService) GetItemsExecute(r ApiGetItemsRequest) (InlineResponse200, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.perPage == nil {
		return localVarReturnValue, nil, reportError("perPage is required and must be specified")
	}

	localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	if r.saleStatus != nil {
		localVarQueryParams.Add("saleStatus", parameterToString(*r.saleStatus, ""))
	}
	if r.onlyAvailableStock != nil {
		localVarQueryParams.Add("onlyAvailableStock", parameterToString(*r.onlyAvailableStock, ""))
	}
	if r.paymentMethod != nil {
		localVarQueryParams.Add("paymentMethod", parameterToString(*r.paymentMethod, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sortDirection", parameterToString(*r.sortDirection, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPaymentIntentByIdRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	paymentIntentId string
}

func (r ApiGetPaymentIntentByIdRequest) MintAccessToken(mintAccessToken string) ApiGetPaymentIntentByIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetPaymentIntentByIdRequest) Execute() (InlineResponse20011, *_nethttp.Response, error) {
	return r.ApiService.GetPaymentIntentByIdExecute(r)
}

/*
 * GetPaymentIntentById This API is responsible to get payment intent by its id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param paymentIntentId
 * @return ApiGetPaymentIntentByIdRequest
 */
func (a *DefaultApiService) GetPaymentIntentById(ctx _context.Context, paymentIntentId string) ApiGetPaymentIntentByIdRequest {
	return ApiGetPaymentIntentByIdRequest{
		ApiService: a,
		ctx: ctx,
		paymentIntentId: paymentIntentId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20011
 */
func (a *DefaultApiService) GetPaymentIntentByIdExecute(r ApiGetPaymentIntentByIdRequest) (InlineResponse20011, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20011
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPaymentIntentById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/paymentIntents/{paymentIntentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentIntentId"+"}", _neturl.PathEscape(parameterToString(r.paymentIntentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProductERC721ByIdRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	id *string
}

func (r ApiGetProductERC721ByIdRequest) MintAccessToken(mintAccessToken string) ApiGetProductERC721ByIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiGetProductERC721ByIdRequest) Id(id string) ApiGetProductERC721ByIdRequest {
	r.id = &id
	return r
}

func (r ApiGetProductERC721ByIdRequest) Execute() (InlineResponse20010, *_nethttp.Response, error) {
	return r.ApiService.GetProductERC721ByIdExecute(r)
}

/*
 * GetProductERC721ById Itemにパックされていて、ItemのstatusがpublishなProductERC721を取得
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetProductERC721ByIdRequest
 */
func (a *DefaultApiService) GetProductERC721ById(ctx _context.Context) ApiGetProductERC721ByIdRequest {
	return ApiGetProductERC721ByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20010
 */
func (a *DefaultApiService) GetProductERC721ByIdExecute(r ApiGetProductERC721ByIdRequest) (InlineResponse20010, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20010
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetProductERC721ById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/products/getProductERC721ById"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	walletAddress *string
}

func (r ApiGetProfileRequest) MintAccessToken(mintAccessToken string) ApiGetProfileRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiGetProfileRequest) WalletAddress(walletAddress string) ApiGetProfileRequest {
	r.walletAddress = &walletAddress
	return r
}

func (r ApiGetProfileRequest) Execute() (InlineResponse20015, *_nethttp.Response, error) {
	return r.ApiService.GetProfileExecute(r)
}

/*
 * GetProfile ウォレットに紐づくプロフィールの取得
 * プロフィールがない場合はnullがdataの値に入る
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetProfileRequest
 */
func (a *DefaultApiService) GetProfile(ctx _context.Context) ApiGetProfileRequest {
	return ApiGetProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20015
 */
func (a *DefaultApiService) GetProfileExecute(r ApiGetProfileRequest) (InlineResponse20015, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20015
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/profile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.walletAddress == nil {
		return localVarReturnValue, nil, reportError("walletAddress is required and must be specified")
	}

	localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSellableItemStockERC721IdRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	itemId *string
}

func (r ApiGetSellableItemStockERC721IdRequest) MintAccessToken(mintAccessToken string) ApiGetSellableItemStockERC721IdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiGetSellableItemStockERC721IdRequest) ItemId(itemId string) ApiGetSellableItemStockERC721IdRequest {
	r.itemId = &itemId
	return r
}

func (r ApiGetSellableItemStockERC721IdRequest) Execute() (InlineResponse2002, *_nethttp.Response, error) {
	return r.ApiService.GetSellableItemStockERC721IdExecute(r)
}

/*
 * GetSellableItemStockERC721Id スマコンで販売している`Item`の販売可能な(まだ売れていない)`ItemStockId`を取得する
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetSellableItemStockERC721IdRequest
 */
func (a *DefaultApiService) GetSellableItemStockERC721Id(ctx _context.Context) ApiGetSellableItemStockERC721IdRequest {
	return ApiGetSellableItemStockERC721IdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2002
 */
func (a *DefaultApiService) GetSellableItemStockERC721IdExecute(r ApiGetSellableItemStockERC721IdRequest) (InlineResponse2002, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2002
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSellableItemStockERC721Id")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/items/getSellableItemStockERC721Id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.itemId == nil {
		return localVarReturnValue, nil, reportError("itemId is required and must be specified")
	}

	localVarQueryParams.Add("itemId", parameterToString(*r.itemId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSignByItemStockIdRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	itemStockId *string
	signatureType *SignatureType
	walletAddress *string
	residence *string
}

func (r ApiGetSignByItemStockIdRequest) MintAccessToken(mintAccessToken string) ApiGetSignByItemStockIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiGetSignByItemStockIdRequest) ItemStockId(itemStockId string) ApiGetSignByItemStockIdRequest {
	r.itemStockId = &itemStockId
	return r
}
func (r ApiGetSignByItemStockIdRequest) SignatureType(signatureType SignatureType) ApiGetSignByItemStockIdRequest {
	r.signatureType = &signatureType
	return r
}
func (r ApiGetSignByItemStockIdRequest) WalletAddress(walletAddress string) ApiGetSignByItemStockIdRequest {
	r.walletAddress = &walletAddress
	return r
}
func (r ApiGetSignByItemStockIdRequest) Residence(residence string) ApiGetSignByItemStockIdRequest {
	r.residence = &residence
	return r
}

func (r ApiGetSignByItemStockIdRequest) Execute() (InlineResponse2003, *_nethttp.Response, error) {
	return r.ApiService.GetSignByItemStockIdExecute(r)
}

/*
 * GetSignByItemStockId Item購入に関してスマコンの操作に必要なSignを返す
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetSignByItemStockIdRequest
 */
func (a *DefaultApiService) GetSignByItemStockId(ctx _context.Context) ApiGetSignByItemStockIdRequest {
	return ApiGetSignByItemStockIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2003
 */
func (a *DefaultApiService) GetSignByItemStockIdExecute(r ApiGetSignByItemStockIdRequest) (InlineResponse2003, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2003
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSignByItemStockId")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/itemStocks/sign"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.itemStockId == nil {
		return localVarReturnValue, nil, reportError("itemStockId is required and must be specified")
	}
	if r.signatureType == nil {
		return localVarReturnValue, nil, reportError("signatureType is required and must be specified")
	}

	localVarQueryParams.Add("itemStockId", parameterToString(*r.itemStockId, ""))
	localVarQueryParams.Add("signatureType", parameterToString(*r.signatureType, ""))
	if r.walletAddress != nil {
		localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	}
	if r.residence != nil {
		localVarQueryParams.Add("residence", parameterToString(*r.residence, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokenERC721ByIdRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	tokenId string
}

func (r ApiGetTokenERC721ByIdRequest) MintAccessToken(mintAccessToken string) ApiGetTokenERC721ByIdRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}

func (r ApiGetTokenERC721ByIdRequest) Execute() (InlineResponse20014, *_nethttp.Response, error) {
	return r.ApiService.GetTokenERC721ByIdExecute(r)
}

/*
 * GetTokenERC721ById get TokenERC721 by Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tokenId
 * @return ApiGetTokenERC721ByIdRequest
 */
func (a *DefaultApiService) GetTokenERC721ById(ctx _context.Context, tokenId string) ApiGetTokenERC721ByIdRequest {
	return ApiGetTokenERC721ByIdRequest{
		ApiService: a,
		ctx: ctx,
		tokenId: tokenId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20014
 */
func (a *DefaultApiService) GetTokenERC721ByIdExecute(r ApiGetTokenERC721ByIdRequest) (InlineResponse20014, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20014
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTokenERC721ById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/tokens/{tokenId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tokenId"+"}", _neturl.PathEscape(parameterToString(r.tokenId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokenERC721sByWalletAddressRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	walletAddress *string
	page *string
	perPage *string
}

func (r ApiGetTokenERC721sByWalletAddressRequest) MintAccessToken(mintAccessToken string) ApiGetTokenERC721sByWalletAddressRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiGetTokenERC721sByWalletAddressRequest) WalletAddress(walletAddress string) ApiGetTokenERC721sByWalletAddressRequest {
	r.walletAddress = &walletAddress
	return r
}
func (r ApiGetTokenERC721sByWalletAddressRequest) Page(page string) ApiGetTokenERC721sByWalletAddressRequest {
	r.page = &page
	return r
}
func (r ApiGetTokenERC721sByWalletAddressRequest) PerPage(perPage string) ApiGetTokenERC721sByWalletAddressRequest {
	r.perPage = &perPage
	return r
}

func (r ApiGetTokenERC721sByWalletAddressRequest) Execute() (InlineResponse20012, *_nethttp.Response, error) {
	return r.ApiService.GetTokenERC721sByWalletAddressExecute(r)
}

/*
 * GetTokenERC721sByWalletAddress walletAddressに紐づくTokenERC721を全て取得する
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetTokenERC721sByWalletAddressRequest
 */
func (a *DefaultApiService) GetTokenERC721sByWalletAddress(ctx _context.Context) ApiGetTokenERC721sByWalletAddressRequest {
	return ApiGetTokenERC721sByWalletAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20012
 */
func (a *DefaultApiService) GetTokenERC721sByWalletAddressExecute(r ApiGetTokenERC721sByWalletAddressRequest) (InlineResponse20012, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20012
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTokenERC721sByWalletAddress")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/tokens/getTokenERC721sByWalletAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.walletAddress == nil {
		return localVarReturnValue, nil, reportError("walletAddress is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.perPage == nil {
		return localVarReturnValue, nil, reportError("perPage is required and must be specified")
	}

	localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokentERC721sByWalletAddressFromAnyContractRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	walletAddress *string
	contractAddress *string
}

func (r ApiGetTokentERC721sByWalletAddressFromAnyContractRequest) MintAccessToken(mintAccessToken string) ApiGetTokentERC721sByWalletAddressFromAnyContractRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiGetTokentERC721sByWalletAddressFromAnyContractRequest) WalletAddress(walletAddress string) ApiGetTokentERC721sByWalletAddressFromAnyContractRequest {
	r.walletAddress = &walletAddress
	return r
}
func (r ApiGetTokentERC721sByWalletAddressFromAnyContractRequest) ContractAddress(contractAddress string) ApiGetTokentERC721sByWalletAddressFromAnyContractRequest {
	r.contractAddress = &contractAddress
	return r
}

func (r ApiGetTokentERC721sByWalletAddressFromAnyContractRequest) Execute() (InlineResponse20012, *_nethttp.Response, error) {
	return r.ApiService.GetTokentERC721sByWalletAddressFromAnyContractExecute(r)
}

/*
 * GetTokentERC721sByWalletAddressFromAnyContract get TokenERC721s by specifying wallet address and contract address
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetTokentERC721sByWalletAddressFromAnyContractRequest
 */
func (a *DefaultApiService) GetTokentERC721sByWalletAddressFromAnyContract(ctx _context.Context) ApiGetTokentERC721sByWalletAddressFromAnyContractRequest {
	return ApiGetTokentERC721sByWalletAddressFromAnyContractRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20012
 */
func (a *DefaultApiService) GetTokentERC721sByWalletAddressFromAnyContractExecute(r ApiGetTokentERC721sByWalletAddressFromAnyContractRequest) (InlineResponse20012, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20012
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTokentERC721sByWalletAddressFromAnyContract")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/tokens/getTokentERC721sByWalletAddressFromAnyContract"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.walletAddress == nil {
		return localVarReturnValue, nil, reportError("walletAddress is required and must be specified")
	}
	if r.contractAddress == nil {
		return localVarReturnValue, nil, reportError("contractAddress is required and must be specified")
	}

	localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	localVarQueryParams.Add("contractAddress", parameterToString(*r.contractAddress, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHasNftRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	walletAddress *string
	contractAddress *string
	tokenId *string
}

func (r ApiHasNftRequest) MintAccessToken(mintAccessToken string) ApiHasNftRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiHasNftRequest) WalletAddress(walletAddress string) ApiHasNftRequest {
	r.walletAddress = &walletAddress
	return r
}
func (r ApiHasNftRequest) ContractAddress(contractAddress string) ApiHasNftRequest {
	r.contractAddress = &contractAddress
	return r
}
func (r ApiHasNftRequest) TokenId(tokenId string) ApiHasNftRequest {
	r.tokenId = &tokenId
	return r
}

func (r ApiHasNftRequest) Execute() (InlineResponse20013, *_nethttp.Response, error) {
	return r.ApiService.HasNftExecute(r)
}

/*
 * HasNft has token id of nft or not in contract
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiHasNftRequest
 */
func (a *DefaultApiService) HasNft(ctx _context.Context) ApiHasNftRequest {
	return ApiHasNftRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20013
 */
func (a *DefaultApiService) HasNftExecute(r ApiHasNftRequest) (InlineResponse20013, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20013
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.HasNft")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/tokens/hasNft"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.walletAddress == nil {
		return localVarReturnValue, nil, reportError("walletAddress is required and must be specified")
	}
	if r.contractAddress == nil {
		return localVarReturnValue, nil, reportError("contractAddress is required and must be specified")
	}
	if r.tokenId == nil {
		return localVarReturnValue, nil, reportError("tokenId is required and must be specified")
	}

	localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	localVarQueryParams.Add("contractAddress", parameterToString(*r.contractAddress, ""))
	localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHasNftsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	walletAddress *string
	contractAddress *string
}

func (r ApiHasNftsRequest) MintAccessToken(mintAccessToken string) ApiHasNftsRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiHasNftsRequest) WalletAddress(walletAddress string) ApiHasNftsRequest {
	r.walletAddress = &walletAddress
	return r
}
func (r ApiHasNftsRequest) ContractAddress(contractAddress string) ApiHasNftsRequest {
	r.contractAddress = &contractAddress
	return r
}

func (r ApiHasNftsRequest) Execute() (InlineResponse20013, *_nethttp.Response, error) {
	return r.ApiService.HasNftsExecute(r)
}

/*
 * HasNfts has nfts or not in contract
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiHasNftsRequest
 */
func (a *DefaultApiService) HasNfts(ctx _context.Context) ApiHasNftsRequest {
	return ApiHasNftsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20013
 */
func (a *DefaultApiService) HasNftsExecute(r ApiHasNftsRequest) (InlineResponse20013, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20013
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.HasNfts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/tokens/hasNfts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}
	if r.walletAddress == nil {
		return localVarReturnValue, nil, reportError("walletAddress is required and must be specified")
	}
	if r.contractAddress == nil {
		return localVarReturnValue, nil, reportError("contractAddress is required and must be specified")
	}

	localVarQueryParams.Add("walletAddress", parameterToString(*r.walletAddress, ""))
	localVarQueryParams.Add("contractAddress", parameterToString(*r.contractAddress, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProfileRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mintAccessToken *string
	inlineObject2 *InlineObject2
}

func (r ApiUpdateProfileRequest) MintAccessToken(mintAccessToken string) ApiUpdateProfileRequest {
	r.mintAccessToken = &mintAccessToken
	return r
}
func (r ApiUpdateProfileRequest) InlineObject2(inlineObject2 InlineObject2) ApiUpdateProfileRequest {
	r.inlineObject2 = &inlineObject2
	return r
}

func (r ApiUpdateProfileRequest) Execute() (InlineResponse20016, *_nethttp.Response, error) {
	return r.ApiService.UpdateProfileExecute(r)
}

/*
 * UpdateProfile ウォレットに紐づくプロフィールの作成
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateProfileRequest
 */
func (a *DefaultApiService) UpdateProfile(ctx _context.Context) ApiUpdateProfileRequest {
	return ApiUpdateProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20016
 */
func (a *DefaultApiService) UpdateProfileExecute(r ApiUpdateProfileRequest) (InlineResponse20016, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20016
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sdk_v4/profile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.mintAccessToken == nil {
		return localVarReturnValue, nil, reportError("mintAccessToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["mint-access-token"] = parameterToString(*r.mintAccessToken, "")
	// body params
	localVarPostBody = r.inlineObject2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
